\chapter{Конструкторская часть}

\section{Схемы алгоритмов}

На рисунке \ref{img:bubble} приведена схема классического алгоритма сортировки пузырьком.

На рисунке \ref{img:insert} приведена схема алгоритма сортировки вставками.

На рисунке \ref{img:quick} приведена схема быстрой сортировки вместе с алгоритмом разделения \ref{img:partition}.

\newpage
\img{18cm}{bubble}{Схема алгоритма сортировки пузырьком}

\newpage
\img{18cm}{insert}{Схема алгоритма сортировки вставками}

\newpage
\img{18cm}{quick}{Схема алгоритма быстрой сортировки}

\newpage
\img{18cm}{partition}{Схема алгоритма разделения}


\section{Трудоемкость алгоритмов}
Введем модель трудоемкости для оценки алгоритмов:
\begin{itemize}
	\item  базовые операции стоимостью 1 — +, -, *, /, =, ==, <=, >=, !=, +=, [], ++, -- получение полей класса;
	\item оценка трудоемкости цикла: Fц = a + N*(a + Fтела), где a - условие цикла;
	\item стоимость условного перехода возьмем за 0, стоимость вычисления условия остаётся.
\end{itemize}


\subsection{Сортировка вставками}

В таблице \ref{tabular:insert_compl} приведена построчная оценка трудоемкости алгоритма сортировки вставками.

\begin{table}[h]
	\begin{center}
		\caption{Построчная оценка веса}
		\label{tabular:insert_compl}
		\begin{tabular}{|l c|} 
			\hline
			Код & Вес \\ [0.5ex] 
			\hline
			for i in range(1, len(a)): & 1+n*2\\
			\hline
			key = a[i] & 2\\
			\hline
			j = i-1 & 2\\
			\hline
			while (j >= 0 and a[j] > key): & n*4\\
			\hline
			a[j+1] = a[j] & 4\\
			\hline
			\j -= 1 & 1\\
			\hline
			a[j+1] = key & 3\\
			\hline
		\end{tabular}
	\end{center}
\end{table}


\textbf{Лучший случай:} отсортированный массив. При этом все внутренние циклы состоят всего из одной итерации.\newline
Трудоемкость: $T(n) = 1 + 2n * (2+2+3)  =  2n * 7 = 14n + 1 = O(n)$

\textbf{Худший случай:} массив отсортирован в обратном нужному порядке. Каждый новый элемент сравнивается со всеми в отсортированной последовательности.
Все внутренние циклы будут состоять из j итераций. \newline
Трудоемкость: $T(n) = 1+n*(2+2+4n*(4+1)+3) = 2n*n+7n+1 =  O(n^{2})$

\subsection{Сортировка пузырьком}
\textbf{Лучший случай:} Массив отсортирован; не произошло ни одного обмена за 1 проход -> выходим из цикла \newline
Трудоемкость:  $1+2n*(1 + 2n*4) = 1+2n+16n*n=  O(n^{2})$

\textbf{Худший случай:}  Массив отсортирован в обратном порядке; в каждом случае происходил обмен\newline
Трудоемкость: $1+2n*(1 + 2n*(4+5)) = O(n^2)$

\subsection{Быстрая сортировка}
\hspace*{5mm}
\textbf{Лучший случай:} сбалансированное дерево вызовов$^{[2]}$ \(O(n*log(n))\)  
В наиболее благоприятном случае процедура PARTITION приводит к двум подзадачам, размер каждой из которых не превышает $\frac{n}{2}$, поскольку размер одной из них равен $\frac{n}{2}$ , а второй$\frac{n}{2} - 1$. В такой ситуации быстрая сортировка работает намного производительнее, и время ее работы описывается следующим рекуррентным соотношением: $T(n) = 2T(\frac{n}{2}) + O(n)$,где мы не обращаем внимания на неточность, связанную с игнорированием функций “пол” и “потолок”, и вычитанием 1. Это рекуррентное соотношение имеет решение ; $T(n) =O(nlgn)$. При сбалансированности двух частей разбиения на каждом уровне рекурсии мы получаем асимптотически более быстрый алгоритм.

Фактически любое разбиение, характеризующееся конечной константой пропорциональности, приводит к образованию дерева рекурсии высотой $O(lgn)$ со стоимостью каждого уровня, равной $O(n)$. Следовательно, при любой постоянной пропорции разбиения полное время работы быстрой сортировки составляет $O(nlgn)$.

\textbf{Худший случай:} несбалансированное дерево $^{[2]}$ $O(n^2)$
Поскольку рекурсивный вызов процедуры разбиения, на вход которой подается массив размером 0, приводит к немедленному возврату из этой процедуры без выполнения каких-ли-бо операций, $T(0) = O(1)$. Таким образом, рекуррентное соотношение, описывающее время работы процедуры в указанном случае, записывается следующим образом: 
$T(n) =T(n-1) +T(0) + O(n) =T(n-1) + O(n)$. Интуитивно понятно, что при суммировании промежутков времени, затрачиваемых на каждый уровень рекурсии, получается арифметическая прогрессия, что приводит к результату $O(n^2)$.



\section*{Вывод}

На основе теоретических данных, полученных из аналитического раздела были построены схемы требуемых алгоритмов, были установлены лучшие и худшие случаи для алгоритмов сортировок.\newline

\noindent Сортировка пузырьком: лучший - $O(n)$, худший - $O(n^2)$ \newline
Сортировка вставками: лучший - $O(n)$, худший - $O(n^2)$ \newline
Быстрая сортировка: лучший - $O(nlgn)$, худший - $O(n^2)$ \newline


